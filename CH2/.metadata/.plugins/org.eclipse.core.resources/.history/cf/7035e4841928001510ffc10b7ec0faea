import java.util.NoSuchElementException;


public class IndexMinPQ<Key extends Comparable<Key>>{
	private int N;
	private int[] pq;    //pq[i] gives the position of i in qp
	private int[] qp;    //qp[i] gives the position of i in pq, index j s.t pq[j] is i
	private Key[] keys;
	
	@SuppressWarnings("unchecked")
	public IndexMinPQ(int initCapacity) {
		N = 0;
		keys = (Key[]) new Comparable[initCapacity + 1];
		pq = new int[initCapacity + 1];
		qp = new int[initCapacity + 1];
		for (int i = 0; i <= initCapacity; i++) qp[i] = -1;
	}
	
	public IndexMinPQ() {
		this(1);
	}
	
	private void swim(int k) {
		while (k > 1 && less(k, k/2)) {
			exch(k/2, k);
			k = k/2;
		}
	}
	
	private void sink(int k) {
		while (2*k <= N) {
			int j = 2 * k;
			if (j < N && less(j+1, j)) j++;
			if (!less(j, k)) break;
			exch(j, k);
			k = j;
		}
	}
	
	private void exch(int i, int j) {
		int id1 = pq[i];   //id1 is location of ith object in qp
		int id2 = pq[j];   //id2 is location of jth object in qp
		pq[i] = id2;
		pq[j] = id1;
		qp[id1] = j;
		qp[id2] = i;
		//could swap and then qp[pq[i]] = i; qp[pq[j]] = j;
	}
	
	private boolean less(int i, int j) {
		Key v = keys[pq[i]];
		Key w = keys[pq[j]];
		return (v.compareTo(w) < 0);
	}
	
	
	public void insert(int i, Key key) {
		if (contains(i)) throw new IllegalArgumentException("index is already in the priority queue");
		N++;
		qp[i] = N;
		pq[N] = i;
		keys[i] = key;
		swim(N);
		assert isValidIndexMinPQ();
	}
	
	public void changeKey(int i, Key key) {
		if (!contains(i)) throw new NoSuchElementException("Index is not in the priority queue");
		keys[i] = key;
		swim(qp[i]);   //key could need to go up or down
		sink(qp[i]);
		assert isValidIndexMinPQ();
	}
	/**
	 * returns true if index is already taken
	 * @param i - index of element in qp
	 * @return
	 */
	public boolean contains(int i) {
		return (qp[i] != -1);
	}
	
	public void delete(int i) {
		if (!contains(i)) throw new NoSuchElementException("index is not in the priority queue");
		int index = qp[i];   //location of i in pq
		exch(index, N--);
		//could null out pq[N+1];
		swim(index);
		sink(index);
		keys[i] = null;
		qp[i] = -1;
		assert isValidIndexMinPQ();
	}
	
	private boolean isValidIndexMinPQ() {
		//first check to make sure qp[pq[i]] == i for all i
		for (int i = 1; i <= N; i++) {
			if (qp[pq[i]] != i) return false;
		}
		return validateMinHeap(1);
	}
	
	private boolean validateMinHeap(int k) {
		if (k > N) return true;
		int left = 2*k;
		int right = 2*k + 1;
		if (left <= N && less(left, k)) return false;
		if (right <= N && less(right, k)) return false;
		return validateMinHeap(left) && validateMinHeap(right);
	}
	public Key minKey() {
		return keys[pq[1]];
	}
	
	public int minIndex() {
		return pq[1];
	}
	
	public int delMin() {
		int indexOfMin = pq[1];
		exch(1, N--);
		sink(1);
		keys[indexOfMin] = null;
		qp[indexOfMin] = -1;
		assert isValidIndexMinPQ();
		return indexOfMin;
	}
	
	public boolean isEmpty() {
		return (N == 0);
	}
	
	public int size() {
		return N;
	}
	
	public Key keyOf(int i) {
		return keys[i];
	}
}
